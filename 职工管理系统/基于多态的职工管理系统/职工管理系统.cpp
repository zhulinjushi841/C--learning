#include<iostream>
#include"workerManager.h"
using namespace std;
//
// 职工管理系统
// 1.管理系统需求
// 职工管理系统可以用来管理公司内所有员工的信息
// 本教程主要使用C++来实现一个基于多态的职工管理系统
// 
// 在公司中职工主要分为三类：普通员工、经理、老板，显示信息时，需要显示职工编号
// 职工姓名、职工岗位，以及职责
// 普通员工职责：完成经理交给的任务
// 经理职责：完成老板交给的任务，并下发任务给员工
// 老板职责：管理公司所有事务
// 
// 管理系统中需要实现的功能如下：
// 退出管理程序：退出当前管理系统
// 增加职工信息：实现批量增加职工功能，将信息录入到文件中，职工信息为：职工编号、姓名、部门编号
// 显示职工信息：显示公司内部所有职工的信息
// 删除离职职工：按照编号删除指定的职工
// 修改职工信息：按照编号修改职工个人信息
// 查找职工信息：按照职工的编号或者职工的姓名进行查找相关的人员信息
// 按照编号排序：按照职工编号，进行排序，排序规则由用户指定
// 清空所有文档：清空文件中记录的所有职工信息(清空前需要再次确认，防止误删）
// 
// 2.创建项目
// 创建项目步骤如下：
// 创建新项目
// 添加文件
// 
// 3.创建管理类
// 管理类负责的内容如下：
// 与用户的沟通菜单界面
// 对职工增删改查的操作
// 与文件的读写交互
// 3.1创建文件
// 在头文件和源文件的文件夹下分别创建workManager.h和workerManager.cpp文件
// 
// 4.菜单功能
// 功能描述：与用户的沟通界面
// 4.1添加成员函数
// 在管理类workerManager.h中添加成员函数void Show_Menu();
// 4.2菜单功能实现
// 在管理类workerManager.cpp中实现Show_Menu()函数
// 4.3测试菜单功能
// 在职管理系统.cpp中测试菜单功能
// 
// 5.推出功能
// 5.1提供功能接口
// 在main函数中提供分支选择，提供每个功能接口
// 
// 6.创建职工类
// 6.1创建职工抽象类
// 职工的分类为：普通员工、经理、老板
// 将三种职工抽象到一个类(worker)中，利用多态管理不同职工种类
// 职工的属性为：职工编号、职工姓名、职工所在部门编号
// 职工的行为为：职位职责信息描述 获取职位名称
// 6.2创建普通员工类
// 普通员工类继承职工抽象类，并重写父类中纯虚函数
// 在头文件和源文件的文件夹下分别创建employee.h和employee.cpp
// 6.3创建经理类
// 经理类继承职工抽象类，并重写父类中纯虚函数，和普通员工类似
// 在头文件和源文件中分解创建manager.h和manager.cpp文件
// 6.4创建老板类
// 老板类继承职工抽象类，并重写父类中纯虚函数，和普通员工类似
// 在头文件和源文件的文件夹下分别创建boss.h和boss.cpp文件
// 6.5测试多态
// 在职工管理系统.cpp中添加测试函数，并且运行能够产生多态
// 
// 7添加职工
// 功能描述：批量添加职工，并且保存到文件中
// 7.1功能分析
// 分析：
// 用户在批量创建时，可能会创建不同种类的职工
// 如果想将所有不同种类的员工都放在一个数组中，可以将所有员工的指针维护到一个数组里
// 如果想要在程序中维护这个不定长度的数组，可以将数组创建到堆区，并利用Worker**的指针维护
// 利用多态的特性 可以用父类的指针 指向子类的对象
// 7.2功能实现
// 在WorkerManager.h头文件中添加成员属性 代码：
// 
// 8文件交互-写文件
// 功能描述：对文件进行读写
// 在上一个添加功能中，我们只是将所有的数据添加到了内存中，一旦程序结束就无法保存
// 因此文件管理类中需要一个与文件进行交互的功能，对于文件进行读写操作
// 
// 8.1设定文件路径
// 首先我们将文件路径，在workerManager.h中添加宏常量，并且包含头文件fstream
// 
// 8.2成员函数声明
// 在workerManager.h中类里添加成员函数void save()
// 
// 9文件交互-读文件
// 功能描述：将文件中的内容读取到程序中
// 虽然我们实现了添加职工后保存到文件的操作，但是每次开始运行程序，并没有
// 将文件中数据读取到程序中
// 而我们的程序功能中还有清空文件的需求
// 因此构造函数初始化数据的情况分为三种
// 
// 1.第一次使用，文件未创建
// 2.文件存在，但是数据被用户清空
// 3.文件存在，并且保存职工的所有数据
// 9.1文件未创建
// 在workerManager.h中添加新的成员属性m_FileIsEmpty标志文件是否为空
// 9.2文件存在且数据为空
// 在workerManager.cpp中的构造函数追加代码：
// 9.3文件存在且保存职工数据
// 9.3.1获取记录的职工人数
// 在workerManager.h中添加成员函数 int get_EmpNum();
// 在workerManager.cpp构造函数中继续追加代码
// 9.3.2初始化数组
// 根据职工的数据以及职工数据，初始化workerManager中的Worker** m_empArray指针
// 在WorkerManager.h中添加成员函数 void init_Emp();
// 
// 10显示职工
// 功能描述：显示当前所有职工信息
// 10.1显示职工函数声明
// 在workerManager.h中添加成员函数 void Show_Emp();
// 10.2显示职工函数实现
// 在workerManager.cpp中实现成员函数 void Show_Emp();
// 
// 
// 11删除职工
// 功能描述：按照职工的编号进行删除职工操作
// 11.1删除职工函数声明
// 在workerManager.h中添加成员函数 void Del_Emp();
// 11.2职工是否存在函数声明
// 很多功能都需要用到根据职工是否存在来进行操作如：删除职工、修改职工、查找职工
// 因此添加该公告函数，以便于后续调用
// 在workerManager.h中添加成员函数 int IsExist(int id);
// 
// 12修改职工
// 功能描述：能够按照职工的编号对职工信息进行修改并保存
// 12.1修改职工函数声明
// 在workerManager.h中添加成员函数 void Mod_Emp();
// 12.2修改职工函数实现
// 在workerManager.cpp中实现成员函数 void Mod_Emp();
// 
// 13查找职工
// 功能描述：提供两种查找职工的方式，一种按照职工编号，一种按照职工姓名
// 13.1查找职工函数声明
// 在workerManager.h中添加成员函数 void Find_Emp();
// 13.2查找职工函数实现
// 在workerManager.cpp中实现成员函数void Find_Emp();
// 
// 14排序
// 功能描述：按照职工编号进行排序，排序的顺序由用户指定
// 14.1排序函数声明
// 在workerManager.h中添加成员函数void Sort_Emp();
// 14.2排序函数实现
// 在workerManager.cpp中实现成员函数void Sort_Emp();
// 
// 15.清空文件
// 功能描述：将文件中记录数据清空
// 15.1清空函数声明
// 在workerManager.h中添加成员函数void Clean_File();
// 15.2清空函数实现
// 在workerManager.cpp中实现成员函数void Clean_File();
//
#include"worker.h"
#include"employee.h"


int main()
{
	


	//实例化管理者对象
	WorkerManager wm;
	char choice;

	while (true)
	{
		//调用展示菜单成员函数
		wm.Show_Menu();
		cout << "请输入您的选择：" << endl;
		cin >> choice;

		switch (choice)
		{
		case '0':	//退出系统
			wm.ExitSystem();
			break;
		case '1':	//添加职工
			wm.Add_Emp();
			break;
		case '2':	//显示职工
			wm.Show_Emp();
			break;
		case '3':	//删除职工
			wm.Del_Emp();
			break;
		case '4':	//修改职工
			wm.Mod_Emp();
			break;
		case '5':	//查找职工
			wm.Find_Emp();
			break;
		case '6':	//排序职工
			wm.Sort_Emp();
			break;
		case '7':	//清空文件
			wm.Clean_File();
			break;
		default:
			system("cls");
			break;
		}

	}

	

	system("pause");

	return 0;
}
