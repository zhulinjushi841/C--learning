模板
模板不可直接使用 它只是一个框架 模板的通用并不是通用的
两种方式使用函数模板
1.自动类型推导
mySwap(a, b)
2.显示指定类型
mySwap<int>(a, b)

函数模板的语法：
template<class T>
函数声明或者定义
注意：其中class还可以是typename，一般来说类模板用class 函数模板用 typename 实际两者皆可 一般可以用class

函数模板
注意：
1.自动类型推导 必须推导出一致的数据类型才可以使用
2.模板需确定T的数据类型才可以使用 如果函数体不能帮助编译器推测出T的类型 就需要在调用函数的时候显式指定其类型 例如func<int>()；

普通函数和模板函数的区别
1.普通函数在调用的时候会发生自动类型转换(隐式类型转换)
2.模板函数如果在调用的时候使用了自动类型推导 就不会发生隐式类型转换
一般来说调用模板函数可以直接使用显式指定类型


1.3.2 类模板与函数模板区别
类模板与函数模板区别主要有两点：
1.类模板没有自动类型推导的使用方式
2.类模板在模板参数列表中可以有默认参数

1.3.3 类模板中成员函数创建时机
类模板中成员函数和普通类中成员函数创建时机是有区别的
普通类中的成员函数一开始就可以创建
类模板中的成员函数在调用时才创建


普通函数和模板函数调用的规则
1.若普通函数和模板函数均可，则优先调用普通函数
2.可以通过空模板参数列表强制调用模板函数 例如myPrint<>（a, b);
3.函数模板可以发生函数重载
4.若函数模板可以产生更好的匹配，则涌现使用模板函数 (例如不需用编译器进行类型转换，则用模板)

模板的局限性
模板的通用性并不是万能的	 C++提供模板的重载 并可以为这些特定类型做具体化的模板
模板函数的重载需要考虑到具体化 显示具体化的原型用 template<> 开头，并通过名称来指出类型，可以用来解决自定义的类型的通用化
bool myCompare(Person &p1,Person &p2)
此外，学习模板的真正目的并不是为了写模板 而是能够使用STL(Standard Template Library)也即标准模板库提供的模板

类模板
template<typename/class T>
类的声明或定义
类模板和函数模板的区别主要有两点
1.类模板没有自动类型睿道的使用方式，在实例化时必须进行显式定义
2.类模板在模板参数列表中可有默认参数 例如：
template<class NameType = string, class AgeType =age>

类模板作为函数参数
学习目标
类模板实例化出的对象 向函数传参的方式
一共有三种方式：
1.指定传入的类型——直接显示对象的数据类型 例如： void printP1(Person<string,int> &p );
这种方式是最常用的
2.参数模板化——将对象中的参数变为模板进行传递 例如：
template<class T1, class T2>
void printP2(Person<T1,T2> &p)
3.将整个类模板化——将该对象类型 模板化进行传递
template<class T>
void printP3(T &p)

类模板与继承
类模板遇到继承的时候需要注意：
1.当子类集成的父类是一个类模板时，子类在声明时需要制定父类中T的类型
2.若不指定，编译器就无法为子类分配内存
3.如果想灵活指定父类中T的类型 子类也需要变为类模板

